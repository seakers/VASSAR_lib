function load_functions
r = global_jess_engine();
jess batch ".\\clp\\functions.clp";
jess batch ".\\clp\\jess_functions.clp";
r.eval('(deffunction update-objective-variable (?obj ?new-value) �Update the value of the global variable with the new value only if it is better� (bind ?obj (max ?obj ?new-value)))');
r.eval('(deffunction ContainsRegion (?observed-region ?desired-region) "Returns true if the observed region i.e. 1st param contains the desired region i.e. 2nd param" (bind ?tmp1 (eq ?observed-region Global)) (bind ?tmp2 (eq ?desired-region ?observed-region)) (if (or ?tmp1 ?tmp2) then (return TRUE) else (return FALSE)))');
r.eval('(deffunction ContainsBands (?list-bands ?desired-bands) "Returns true if the list of bands contains the desired bands" (if (subsetp ?desired-bands ?list-bands) then (return TRUE) else (return FALSE)))');

r.eval(['(deffunction numerical-to-fuzzy (?num ?values ?mins ?maxs)' ...
    '(bind ?ind 1)' ...
    '(bind ?n (length$ ?values))' ...
    '(while (<= ?ind ?n)' ... 
    '(if (and (< ?num (nth$ ?ind ?maxs)) (>= ?num (nth$ ?ind ?mins))) then (return (nth$ ?ind ?values))' ...
        'else (++ ?ind))))']);
    
r.eval(['(deffunction revisit-time-to-temporal-resolution (?region ?values)' ...
    '(if (eq ?region Global) then ' ...
        '(return (nth$ 1 ?values))' ...
    ' elif (eq ?region Tropical-regions) then' ... 
        '(return (nth$ 2 ?values))' ...
    ' elif (eq ?region Northern-hemisphere) then' ... 
        '(return (nth$ 3 ?values))' ...
    ' elif (eq ?region Southern-hemisphere) then' ... 
        '(return (nth$ 4 ?values))' ...
    ' elif (eq ?region Cold-regions) then' ... 
        '(return (nth$ 5 ?values))' ...
    ' elif (eq ?region US) then' ... 
        '(return (nth$ 6 ?values))' ...
        '))']);  



r.eval(['(deffunction fuzzy-max (?att ?v1 ?v2) ' ...
    '(if (>= (SameOrBetter ?att ?v1 ?v2) 0) then ' ...
    '?v1 else ?v2))']);

r.eval(['(deffunction fuzzy-min (?att ?v1 ?v2) ' ...
    '(if (<= (SameOrBetter ?att ?v1 ?v2) 0) then ' ...
    '?v1 else ?v2))']);


r.eval(['(deffunction fuzzy-avg (?v1 ?v2) ' ...
    '(if (or (and (eq ?v1 High) (eq ?v2 Low)) (and (eq ?v1 Low) (eq ?v2 High))) then ' ...
    ' "Medium" ' ...
    ' else (fuzzy-min Accuracy ?v1 ?v2)))']);

r.eval(['(deffunction member (?elem ?list) ' ...
    '(if (listp ?list) then ' ...
    ' (neq (member$ ?elem ?list) FALSE) ' ...
    ' else (?list contains ?elem)))']);

r.eval(['(deffunction valid-orbit (?typ ?h ?i ?raan) ' ...
    '(bind ?valid TRUE)' ...
    '(if (and (eq ?typ GEO) (or (neq ?h GEO) (neq ?i 0))) then (bind ?valid FALSE))' ...
    '(if (and (neq ?typ GEO) (eq ?h GEO)) then (bind ?valid FALSE))' ...
    '(if (and (eq ?typ SSO) (neq ?i SSO)) then (bind ?valid FALSE))' ...
    '(if (and (neq ?typ SSO) (eq ?i SSO)) then (bind ?valid FALSE))' ...
    '(if (and (neq ?typ SSO) (neq ?raan NA)) then (bind ?valid FALSE))' ...
    '(if (and (eq ?typ SSO) (eq ?raan NA)) then (bind ?valid FALSE))' ...
    '(if (and (or (eq ?h 1000) (eq ?h 1300)) (neq ?i near-polar)) then (bind ?valid FALSE))' ...
    '(if (and (< ?h 400) (or (neq ?typ LEO) (eq ?i SSO) (eq ?i near-polar))) then (bind ?valid FALSE))' ...
    ' (return ?valid))']);
  
r.eval(['(deffunction worth-improving-measurement (?meas) ' ...
    '(bind ?worth TRUE)' ...
    '(bind ?arr (matlabf get_related_suboj ?meas))' ...
    '(if (eq ?arr nil) then (return FALSE))' ...
    '(bind ?iter (?arr iterator))' ...
    '(while (?iter hasNext) ' ...
    '(bind ?subobj (?iter next)) ' ...
    '(if (eq (eval ?subobj) 1) then (bind ?worth FALSE))) ' ...
    '(return ?worth))']);

jess defadvice before (create$ >= <= < >) (foreach ?xxx $?argv (if (eq ?xxx nil) then (return FALSE)));
jess defadvice before (create$ sqrt + * **) (foreach ?xxx $?argv (if (eq ?xxx nil) then (bind ?xxx 0)));
r.addUserfunction(SameOrBetter);
r.addUserfunction(Improve);
r.addUserfunction(Worsen);

jess deffunction max$ (?list) ...
    (bind ?size (length$ ?list)) (bind ?mx 0) ... 
    (for (bind ?i 1) (<= ?i ?size) (++ ?i) ... 
    (bind ?el (nth$ ?i ?list)) ... 
    (if (> ?el ?mx) then (bind ?mx ?el))) ... 
    (return ?mx);

jess deffunction get-max-nsats (?disregard) ...
 (bind ?result (run-query* HARD-CONSTRAINTS::get-max-sats)) ...
 (if (?result next) then ...
 (bind ?mx (?result getDouble max)) ...
 (return ?mx) ...
 else (return 0));


jess deffunction sequence-to-ordering (?seq) ...
    (bind ?ord (create$ )) ...
    (foreach ?x ?seq (bind ?ord (insert$ ?ord (+ (length$ ?ord) 1) 0))) ...
    (for (bind ?i 1) (<= ?i (length$ ?seq)) (++ ?i) ...
        (bind ?j (nth$ ?i ?seq)) ...
    (bind ?ord (replace$ ?ord ?j ?j ?i)) ...
        ) ...
    (return ?ord);
    

jess deffunction ordering-to-sequence(?ord) ...
    (bind ?seq (create$ )) ...
    (foreach ?x ?ord (bind ?seq (insert$ ?seq (+ (length$ ?seq) 1) 0))) ...
    (for (bind ?i 1) (<= ?i (length$ ?ord)) (++ ?i) ...
        (bind ?j (nth$ ?i ?ord)) ...
    (bind ?seq (replace$ ?seq ?j ?j ?i)) ...
        ) ...
    (return ?seq);
    


jess deffunction check-precedence-in-ordering-binary (?el1 ?el2 ?ord) ...
    "returns TRUE if ?el1 goes before ?el2 and FALSE otherwise" ...
    (return (< (nth$ ?el1 ?ord) (nth$ ?el2 ?ord)));
    

jess deffunction check-precedence-in-sequence-binary (?el1 ?el2 ?seq) ...
    "returns TRUE if ?el1 goes before ?el2 and FALSE otherwise" ...
    (bind ?ord (sequence-to-ordering ?seq)) ...
    (return (check-precedence-in-ordering-binary ?el1 ?el2 ?ord));
    

jess deffunction check-succession-in-ordering-binary (?el1 ?el2 ?ord) ...
    "returns TRUE if ?el1 goes after ?el2 and FALSE otherwise" ...
    (return (not (check-precedence-in-ordering-binary ?el1 ?el2 ?ord)));


jess deffunction check-succession-in-sequence-binary (?el1 ?el2 ?seq) ...
    "returns TRUE if ?el1 goes after ?el2 and FALSE otherwise" ...
    (return (not (check-precedence-in-sequence-binary ?el1 ?el2 ?seq)));
    

jess deffunction check-precedence-in-ordering (?el1 ?list ?ord) ...
    "returns TRUE if ?el1 goes before all elements in ?el2 and FALSE otherwise" ...
    (if (eq (listp ?list) FALSE) then  ...
        (return (check-precedence-in-ordering-binary ?el1 ?list ?ord))) ...
    (if (eq (length$ ?list) 1) then  ...
        (bind ?el2 (nth$ 1 ?list) )  ...
        (return (check-precedence-in-ordering-binary ?el1 ?el2 ?ord)) ...
        else  ...
        (bind ?el2 (nth$ 1 ?list)) ...
        (bind ?res (check-precedence-in-ordering-binary ?el1 ?el2 ?ord)) ...
        (if (eq ?res FALSE ) then (return FALSE) else  ...
            (return (check-precedence-in-ordering ?el1 (rest$ ?list) ?ord))) ...
        );
    

jess deffunction check-precedence-in-sequence (?el1 ?list ?seq) ...
    "returns TRUE if ?el1 goes before ?el2 and FALSE otherwise" ...
    (bind ?ord (sequence-to-ordering ?seq)) ...
    (return (check-precedence-in-ordering  ?el1 ?list ?ord));
    

jess deffunction check-succession-in-ordering (?el1 ?list ?ord) ...
    "returns TRUE if ?el1 goes after all elements in ?el2 and FALSE otherwise" ...
    (if (eq (listp ?list) FALSE) then  ...
        (return (check-succession-in-ordering-binary ?el1 ?list ?ord))) ...
    (if (eq (length$ ?list) 1) then  ...
        (bind ?el2 (nth$ 1 ?list) )  ...
        (return (check-succession-in-ordering-binary ?el1 ?el2 ?ord)) ...
        else  ...
        (bind ?el2 (nth$ 1 ?list)) ...
        (bind ?res (check-succession-in-ordering-binary ?el1 ?el2 ?ord)) ...
        (if (eq ?res FALSE ) then (return FALSE) else  ...
            (return (check-succession-in-ordering ?el1 (rest$ ?list) ?ord))) ...
        );

jess deffunction check-succession-in-sequence (?el1 ?list ?seq) ...
    "returns TRUE if ?el1 goes after ?el2 and FALSE otherwise" ...
    (bind ?ord (sequence-to-ordering ?seq)) ...
    (return (check-succession-in-ordering  ?el1 ?list ?ord));


jess deffunction is-subsequence (?subseq ?seq) ...
	(return (numberp (str-index (implode$ ?subseq) (implode$ ?seq))));
    
jess deffunction min$ (?list) ...
    (return (eval (str-cat "(min " (implode$ ?list) ")" )));


jess deffunction sort$ (?list) ...
    (if (eq (length$ ?list) 1) then (return (nth$ 1 ?list))) ...
    (bind ?mn (min$ ?list)) ...
	(bind ?index (member$ ?mn ?list)) ...
    (bind ?shorter-list (replace$ ?list ?index ?index (create$ ))) ...
    (return (create$ ?mn (sort$ ?shorter-list)));

jess deffunction check-contiguity-in-sequence (?elems ?seq) ...
    (if (eq (length$ ?elems) 1) then (return TRUE)) ...
    (bind ?ord (sequence-to-ordering ?seq)) ...
    (bind ?indexes (create$ )) ...
    (for (bind ?i 1) (<= ?i (length$ ?elems)) (++ ?i)  ...
        (bind ?indexes (insert$ ?indexes ?i (nth$ (nth$ ?i ?elems) ?ord))) ...
        ) ...
    (bind ?indexes (sort$ ?indexes)) ...
    (printout t ?indexes crlf) ...
    (for (bind ?i 1) (< ?i (length$ ?elems)) (++ ?i)  ...
        (if (neq (- (nth$ (+ ?i 1) ?indexes) (nth$ (+ ?i) ?indexes)) 1) then (return FALSE)) ...
        ) ...
    (return TRUE);
    
jess deffunction .*$ (?x ?y) ...
    (if (not (listp ?x)) then (return (* ?x ?y))) ...
    (bind ?z (create$ )) ...
    (for (bind ?i 1) (<= ?i (length$ ?x)) (++ ?i) ...
        (bind ?tmp (* (nth$ ?i ?x) (nth$ ?i ?y))) (bind ?z (insert$ ?z ?i ?tmp))) ...
    (return ?z);

jess deffunction dot-product$ (?x ?y) ...
    (return (sum$ (.*$ ?x ?y)));
    
jess deffunction is-domestic (?who) ...
    (return (eq (sub-string 1 3 ?who) DOM));
    
jess deffunction meas-group (?p ?gr) ...
    (if (eq (str-compare (sub-string 1 1 ?p) A) 0) then (return FALSE)) ...
    (bind ?pos (str-index " " ?p)) ...
    (bind ?str (sub-string 1 (- ?pos 1) ?p)) ...
    (bind ?meas-1 (nth$ 1 (get-meas-group ?str))) ... 
    (bind ?meas-2 (nth$ 2 (get-meas-group ?str))) ... 
    (bind ?meas-3 (nth$ 3 (get-meas-group ?str))) ... 
    (bind ?gr-1 (nth$ 1 (get-meas-group ?gr))) ... 
    (bind ?gr-2 (nth$ 2 (get-meas-group ?gr))) ... 
    (bind ?gr-3 (nth$ 3 (get-meas-group ?gr))) ...  
    (if (and (neq (str-compare ?gr-1 ?meas-1) 0) (neq (str-compare ?gr-1 0) 0)) then (return FALSE)) ...
    (if (and (neq (str-compare ?gr-2 ?meas-2) 0) (neq (str-compare ?gr-2 0) 0)) then (return FALSE)) ...
    (if (and (neq (str-compare ?gr-3 ?meas-3) 0) (neq (str-compare ?gr-3 0) 0)) then (return FALSE)) ...
            (return TRUE);

jess deffunction get-meas-group (?str) ...
    (bind ?pos (str-index . ?str)) ...
    (bind ?gr1 (sub-string 1 (- ?pos 1) ?str)) ...
    (bind ?new-str (sub-string (+ ?pos 1) (str-length ?str) ?str)) ...
    (bind ?pos2 (str-index . ?new-str)) ...
    (bind ?gr2 (sub-string 1 (- ?pos2 1) ?new-str)) ...
    (bind ?gr3 (sub-string (+ ?pos2 1) (str-length ?new-str) ?new-str)) ...
    (return (create$ ?gr1 ?gr2 ?gr3));
    
jess deffunction torad (?deg) ...
    (return (* (pi) (/ ?deg 180)));
    

jess deffunction todeg (?rad) ...
    (return (* 180 (/ ?rad (pi))));

jess deffunction between (?x ?lo ?hi) ...
    (bind ?y ?x) ...
    (return (and (>= ?x ?lo) (<= ?y ?hi)));
    
%% Matlab (Jorge)

    jess defglobal...
            ?*matlab* = ((new matlabcontrol.MatlabProxyFactory) getProxy);
    
    jess deffunction matlab (?code)... code is a string
            (?*matlab* eval ?code);
    
    jess deffunction matlabf0 (?f $?argv)...
            (?*matlab* feval ?f ?argv);

    jess deffunction matlabfn (?f ?nout $?argv)...
            ... the return values need conversion!
            (?*matlab* returningFeval ?f ?nout ?argv);

    jess deffunction matlab-value (?v)...
            (if (not (java-objectp ?v)) then...
                ... already a Jess value
                (return ?v)...
            elif (not ((?v getClass) isArray)) then ...
                ... normal Java object
                (return ?v) ...
            else ...
                ... Java array of doubles
                (bind ?l (as-list ?v)) ...
                (if (> (length$ ?l) 1) then ...
                    ... many values
                    (return ?l) ...
                else ...
                    ... one value
                    (return (nth$ 1 ?l))));

    jess deffunction matlabf1 (?f $?argv) ...
            (matlab-value (nth$ 1 (matlabfn ?f 1 $?argv)));
    
    jess deffunction matlab-nargout (?f) ...
            (bind ?result (matlabf1 nargout ?f)) ...
            (if (>= ?result 0) then ...
                ?result ...
            else ... last one is varargout
                (- 0 ?result 1));
    
    jess deffunction matlabf (?f $?argv)...
            (bind ?nout (matlab-nargout ?f))...
            (if (= ?nout 0) then...
                (matlabf0 ?f $?argv)...
            elif (= ?nout 1) then...
                (matlabf1 ?f $?argv)...
            else... doesn't work yet
                (matlabfn ?f ?nout $?argv));
            
return