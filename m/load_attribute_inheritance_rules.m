function load_attribute_inheritance_rules
%% load_attribute_inheritance_rules.m
global params
r = global_jess_engine();
r.eval(['(bind ?att_inheritance_clp_file "' params.attribute_inheritance_clp '")']);
r.eval('(batch ?att_inheritance_clp_file)');
jess batch ".\\clp\\orbit_rules.clp";
[~,txt,~] = xlsread(params.template_definition_xls,'Attribute Inheritance');
miss2instr = txt(:,1:2);
instr2meas = txt(:,3:4);

%% Mission to instrument
for i =2:size(miss2instr,1)
    att = miss2instr{i,1};
    inherit = miss2instr{i,2};
    if strcmp(inherit,'Instrument Database') % Inherit directly from DATABASE::Instrument
        call = ['(defrule MANIFEST::get-' att '-from-database ' ...
        ' (declare (salience 10)) ' ...
        ' ?instr <- (CAPABILITIES::Manifested-instrument (Name ?name) (' att ' nil)) ' ...
        ' (DATABASE::Instrument (Name ?name) (' att ' ?value&:(neq ?value nil))) ' ...
         ' => ' ...
        ' (modify ?instr (' att ' ?value)) ' ...
        ' )'];
        r.eval(call);
    elseif strcmp(inherit,'Mission') % Inherit directly from Mission (typically not necessary because rule assert-manifested-instruments already does it for you
        call = ['(defrule MANIFEST::get-' att '-from-mission ' ...
        ' (declare (salience 10)) ' ...
        ' ?instr <- (CAPABILITIES::Manifested-instrument (Name ?name) (flies-in ?miss) (' att ' nil)) ' ...
        ' (MANIFEST::Mission (Name ?miss) (' att ' ?value&:(neq ?value nil))) ' ...
         ' => ' ...
        ' (modify ?instr (' att ' ?value)) ' ...
        ' )'];
        r.eval(call);
    end
    
    
end

%% Instrument to measurement
for i =2:size(instr2meas,1)
    att = instr2meas{i,1};
    inherit = instr2meas{i,2};
    if strcmp(inherit,'Instrument') % Inherit directly from Instrument
        call = ['(defrule CAPABILITIES::get-' att '-from-instrument ' ...
        ' (declare (salience -10)) ' ...
        ' ?meas <- (REQUIREMENTS::Measurement (taken-by ?instr) (' att ' nil)) ' ...
        ' (CAPABILITIES::Manifested-instrument (Name ?instr) (' att ' ?value&:(neq ?value nil))) ' ...
         ' => ' ...
        ' (modify ?meas (' att ' ?value)) ' ...
        ' )'];
        r.eval(call);
    end
    
    
end


return